/*
对于除法：结果的小数部分舍弃，两个运算对象符号不同，结果为-
对于取余：根据-的位置，-m%n=-(m%n),m%(-n)=m%n
if(p=getPtr()!=0)--优先级相同，从右向左，先判断getPtr()是否为空，再赋值给P
对于前置++和后置++,前置++是将变量++后作为左值返回，而后置++是先将原对象作为右值返回，再进行++操作，这样后置++就可以对变量进行修改
*p++表示先进行解引用，之后再对p指针进行++的位置移动操作
string s="???";string p=s+s[s.size()-1]=='s'?"":"s";这个语句是从左向右解析，将二者拼接起来再比较是否为's'
bool judgement;judgemnet?x++,y++:x--,y--;等价为(judgemnet?x++,y++:x--),y--;
先判断judgement是否为假，若为真执行x++,y++最后执行y--，若为假执行x--,y--
对于const修饰的变量使用static_cast强制类型转换时需要先对其进行const_cast的强制类型转化去除const属性
例如const string * ps;void* i=static_cast<void*>(const_cast<string*>(ps))
-----------------------------------
语句
char line;while(cin>>line){……}这种写法类似于先把输入的字符(串)存放到一个地方,line一个字符一个字符的去访问
在switch语句中case分支中不能定义一个变量，因为如果进入下一个分支，而这个变量是在上一个分支定义的，则不能使用
不能直接多个case分支写在一起--case 1,2,3,4:这样
case标签必须为常量而不能为变量，int a; case a:这样是不对的，需要改为const int a
----------------------------
异常处理的基本语法
try
{
	尝试执行的语句
	if(某种情况)
	{
		throw ……(这可以是一个类型变量,也可以是一个别的错误)
	}
	catch(……)
	{
		
	}
}
*/